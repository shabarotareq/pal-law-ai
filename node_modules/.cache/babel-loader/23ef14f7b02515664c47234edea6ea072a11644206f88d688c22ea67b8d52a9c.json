{"ast":null,"code":"import { BufferGeometry, InterleavedBuffer, InterleavedBufferAttribute, Mesh, MeshBasicMaterial, Vector3, Texture, NearestFilter, RawShaderMaterial, Color, Vector2, AdditiveBlending, Box2, Vector4 } from \"three\";\nconst Lensflare = /* @__PURE__ */(() => {\n  class Lensflare2 extends Mesh {\n    constructor() {\n      super(Lensflare2.Geometry, new MeshBasicMaterial({\n        opacity: 0,\n        transparent: true\n      }));\n      this.isLensflare = true;\n      this.type = \"Lensflare\";\n      this.frustumCulled = false;\n      this.renderOrder = Infinity;\n      const positionScreen = new Vector3();\n      const positionView = new Vector3();\n      const tempMap = new Texture({\n        width: 16,\n        height: 16\n      });\n      tempMap.isFramebufferTexture = true;\n      tempMap.magFilter = NearestFilter;\n      tempMap.minFilter = NearestFilter;\n      tempMap.generateMipmaps = false;\n      tempMap.needsUpdate = true;\n      const occlusionMap = new Texture({\n        width: 16,\n        height: 16\n      });\n      occlusionMap.isFramebufferTexture = true;\n      occlusionMap.magFilter = NearestFilter;\n      occlusionMap.minFilter = NearestFilter;\n      occlusionMap.generateMipmaps = false;\n      occlusionMap.needsUpdate = true;\n      const geometry = Lensflare2.Geometry;\n      const material1a = new RawShaderMaterial({\n        uniforms: {\n          scale: {\n            value: null\n          },\n          screenPosition: {\n            value: null\n          }\n        },\n        vertexShader: (/* glsl */\n        `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform vec3 screenPosition;\n\t\t\t\tuniform vec2 scale;\n\n\t\t\t\tattribute vec3 position;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );\n\n\t\t\t\t}`),\n        fragmentShader: (/* glsl */\n        `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );\n\n\t\t\t\t}`),\n        depthTest: true,\n        depthWrite: false,\n        transparent: false\n      });\n      const material1b = new RawShaderMaterial({\n        uniforms: {\n          map: {\n            value: tempMap\n          },\n          scale: {\n            value: null\n          },\n          screenPosition: {\n            value: null\n          }\n        },\n        vertexShader: (/* glsl */\n        `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform vec3 screenPosition;\n\t\t\t\tuniform vec2 scale;\n\n\t\t\t\tattribute vec3 position;\n\t\t\t\tattribute vec2 uv;\n\n\t\t\t\tvarying vec2 vUV;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUV = uv;\n\n\t\t\t\t\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );\n\n\t\t\t\t}`),\n        fragmentShader: (/* glsl */\n        `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform sampler2D map;\n\n\t\t\t\tvarying vec2 vUV;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = texture2D( map, vUV );\n\n\t\t\t\t}`),\n        depthTest: false,\n        depthWrite: false,\n        transparent: false\n      });\n      const mesh1 = new Mesh(geometry, material1a);\n      const elements = [];\n      const shader = LensflareElement.Shader;\n      const material2 = new RawShaderMaterial({\n        uniforms: {\n          map: {\n            value: null\n          },\n          occlusionMap: {\n            value: occlusionMap\n          },\n          color: {\n            value: new Color(16777215)\n          },\n          scale: {\n            value: new Vector2()\n          },\n          screenPosition: {\n            value: new Vector3()\n          }\n        },\n        vertexShader: shader.vertexShader,\n        fragmentShader: shader.fragmentShader,\n        blending: AdditiveBlending,\n        transparent: true,\n        depthWrite: false\n      });\n      const mesh2 = new Mesh(geometry, material2);\n      this.addElement = function (element) {\n        elements.push(element);\n      };\n      const scale = new Vector2();\n      const screenPositionPixels = new Vector2();\n      const validArea = new Box2();\n      const viewport = new Vector4();\n      this.onBeforeRender = function (renderer, scene, camera) {\n        renderer.getCurrentViewport(viewport);\n        const invAspect = viewport.w / viewport.z;\n        const halfViewportWidth = viewport.z / 2;\n        const halfViewportHeight = viewport.w / 2;\n        let size = 16 / viewport.w;\n        scale.set(size * invAspect, size);\n        validArea.min.set(viewport.x, viewport.y);\n        validArea.max.set(viewport.x + (viewport.z - 16), viewport.y + (viewport.w - 16));\n        positionView.setFromMatrixPosition(this.matrixWorld);\n        positionView.applyMatrix4(camera.matrixWorldInverse);\n        if (positionView.z > 0) return;\n        positionScreen.copy(positionView).applyMatrix4(camera.projectionMatrix);\n        screenPositionPixels.x = viewport.x + positionScreen.x * halfViewportWidth + halfViewportWidth - 8;\n        screenPositionPixels.y = viewport.y + positionScreen.y * halfViewportHeight + halfViewportHeight - 8;\n        if (validArea.containsPoint(screenPositionPixels)) {\n          renderer.copyFramebufferToTexture(screenPositionPixels, tempMap);\n          let uniforms = material1a.uniforms;\n          uniforms[\"scale\"].value = scale;\n          uniforms[\"screenPosition\"].value = positionScreen;\n          renderer.renderBufferDirect(camera, null, geometry, material1a, mesh1, null);\n          renderer.copyFramebufferToTexture(screenPositionPixels, occlusionMap);\n          uniforms = material1b.uniforms;\n          uniforms[\"scale\"].value = scale;\n          uniforms[\"screenPosition\"].value = positionScreen;\n          renderer.renderBufferDirect(camera, null, geometry, material1b, mesh1, null);\n          const vecX = -positionScreen.x * 2;\n          const vecY = -positionScreen.y * 2;\n          for (let i = 0, l = elements.length; i < l; i++) {\n            const element = elements[i];\n            const uniforms2 = material2.uniforms;\n            uniforms2[\"color\"].value.copy(element.color);\n            uniforms2[\"map\"].value = element.texture;\n            uniforms2[\"screenPosition\"].value.x = positionScreen.x + vecX * element.distance;\n            uniforms2[\"screenPosition\"].value.y = positionScreen.y + vecY * element.distance;\n            size = element.size / viewport.w;\n            const invAspect2 = viewport.w / viewport.z;\n            uniforms2[\"scale\"].value.set(size * invAspect2, size);\n            material2.uniformsNeedUpdate = true;\n            renderer.renderBufferDirect(camera, null, geometry, material2, mesh2, null);\n          }\n        }\n      };\n      this.dispose = function () {\n        material1a.dispose();\n        material1b.dispose();\n        material2.dispose();\n        tempMap.dispose();\n        occlusionMap.dispose();\n        for (let i = 0, l = elements.length; i < l; i++) {\n          elements[i].texture.dispose();\n        }\n      };\n    }\n  }\n  const _geometry = new BufferGeometry();\n  const interleavedBuffer = new InterleavedBuffer(new Float32Array([-1, -1, 0, 0, 0, 1, -1, 0, 1, 0, 1, 1, 0, 1, 1, -1, 1, 0, 0, 1]), 5);\n  _geometry.setIndex([0, 1, 2, 0, 2, 3]);\n  _geometry.setAttribute(\"position\", new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));\n  _geometry.setAttribute(\"uv\", new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));\n  Lensflare2.Geometry = _geometry;\n  return Lensflare2;\n})();\nconst LensflareElement = /* @__PURE__ */(() => {\n  class LensflareElement2 {\n    constructor(texture, size = 1, distance = 0, color = new Color(16777215)) {\n      this.texture = texture;\n      this.size = size;\n      this.distance = distance;\n      this.color = color;\n    }\n  }\n  LensflareElement2.Shader = {\n    uniforms: {\n      map: {\n        value: null\n      },\n      occlusionMap: {\n        value: null\n      },\n      color: {\n        value: null\n      },\n      scale: {\n        value: null\n      },\n      screenPosition: {\n        value: null\n      }\n    },\n    vertexShader: (/* glsl */\n    `\n\n      precision highp float;\n\n      uniform vec3 screenPosition;\n      uniform vec2 scale;\n\n      uniform sampler2D occlusionMap;\n\n      attribute vec3 position;\n      attribute vec2 uv;\n\n      varying vec2 vUV;\n      varying float vVisibility;\n\n      void main() {\n\n        vUV = uv;\n\n        vec2 pos = position.xy;\n\n        vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\n        visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\n        visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\n        visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\n        visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\n        visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\n        visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\n        visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\n        visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\n\n        vVisibility =        visibility.r / 9.0;\n        vVisibility *= 1.0 - visibility.g / 9.0;\n        vVisibility *=       visibility.b / 9.0;\n\n        gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n\n      }\n    `),\n    fragmentShader: (/* glsl */\n    `\n\n      precision highp float;\n\n      uniform sampler2D map;\n      uniform vec3 color;\n\n      varying vec2 vUV;\n      varying float vVisibility;\n\n      void main() {\n\n        vec4 texture = texture2D( map, vUV );\n        texture.a *= vVisibility;\n        gl_FragColor = texture;\n        gl_FragColor.rgb *= color;\n\n      }\n    `)\n  };\n  return LensflareElement2;\n})();\nexport { Lensflare, LensflareElement };\n//# sourceMappingURL=Lensflare.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}