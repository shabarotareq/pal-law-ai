{"ast":null,"code":"import { Vector2 } from \"three\";\nconst DepthLimitedBlurShader = {\n  defines: {\n    KERNEL_RADIUS: 4,\n    DEPTH_PACKING: 1,\n    PERSPECTIVE_CAMERA: 1\n  },\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    size: {\n      value: /* @__PURE__ */new Vector2(512, 512)\n    },\n    sampleUvOffsets: {\n      value: [/* @__PURE__ */new Vector2(0, 0)]\n    },\n    sampleWeights: {\n      value: [1]\n    },\n    tDepth: {\n      value: null\n    },\n    cameraNear: {\n      value: 10\n    },\n    cameraFar: {\n      value: 1e3\n    },\n    depthCutoff: {\n      value: 10\n    }\n  },\n  vertexShader: (/* glsl */\n  `\n    #include <common>\n\n    uniform vec2 size;\n\n    varying vec2 vUv;\n    varying vec2 vInvSize;\n\n    void main() {\n    \tvUv = uv;\n    \tvInvSize = 1.0 / size;\n\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    }\n  `),\n  fragmentShader: (/* glsl */\n  `\n    #include <common>\n    #include <packing>\n\n    uniform sampler2D tDiffuse;\n    uniform sampler2D tDepth;\n\n    uniform float cameraNear;\n    uniform float cameraFar;\n    uniform float depthCutoff;\n\n    uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];\n    uniform float sampleWeights[ KERNEL_RADIUS + 1 ];\n\n    varying vec2 vUv;\n    varying vec2 vInvSize;\n\n    float getDepth( const in vec2 screenPosition ) {\n    \t#if DEPTH_PACKING == 1\n    \treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\n    \t#else\n    \treturn texture2D( tDepth, screenPosition ).x;\n    \t#endif\n    }\n\n    float getViewZ( const in float depth ) {\n    \t#if PERSPECTIVE_CAMERA == 1\n    \treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\n    \t#else\n    \treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\n    \t#endif\n    }\n\n    void main() {\n    \tfloat depth = getDepth( vUv );\n    \tif( depth >= ( 1.0 - EPSILON ) ) {\n    \t\tdiscard;\n    \t}\n\n    \tfloat centerViewZ = -getViewZ( depth );\n    \tbool rBreak = false, lBreak = false;\n\n    \tfloat weightSum = sampleWeights[0];\n    \tvec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;\n\n    \tfor( int i = 1; i <= KERNEL_RADIUS; i ++ ) {\n\n    \t\tfloat sampleWeight = sampleWeights[i];\n    \t\tvec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;\n\n    \t\tvec2 sampleUv = vUv + sampleUvOffset;\n    \t\tfloat viewZ = -getViewZ( getDepth( sampleUv ) );\n\n    \t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;\n\n    \t\tif( ! rBreak ) {\n    \t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\n    \t\t\tweightSum += sampleWeight;\n    \t\t}\n\n    \t\tsampleUv = vUv - sampleUvOffset;\n    \t\tviewZ = -getViewZ( getDepth( sampleUv ) );\n\n    \t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;\n\n    \t\tif( ! lBreak ) {\n    \t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\n    \t\t\tweightSum += sampleWeight;\n    \t\t}\n\n    \t}\n\n    \tgl_FragColor = diffuseSum / weightSum;\n    }\n  `)\n};\nconst BlurShaderUtils = {\n  createSampleWeights: (kernelRadius, stdDev) => {\n    const gaussian = (x, stdDev2) => {\n      return Math.exp(-(x * x) / (2 * (stdDev2 * stdDev2))) / (Math.sqrt(2 * Math.PI) * stdDev2);\n    };\n    const weights = [];\n    for (let i = 0; i <= kernelRadius; i++) {\n      weights.push(gaussian(i, stdDev));\n    }\n    return weights;\n  },\n  createSampleOffsets: (kernelRadius, uvIncrement) => {\n    const offsets = [];\n    for (let i = 0; i <= kernelRadius; i++) {\n      offsets.push(uvIncrement.clone().multiplyScalar(i));\n    }\n    return offsets;\n  },\n  configure: (shader, kernelRadius, stdDev, uvIncrement) => {\n    shader.defines[\"KERNEL_RADIUS\"] = kernelRadius;\n    shader.uniforms[\"sampleUvOffsets\"].value = BlurShaderUtils.createSampleOffsets(kernelRadius, uvIncrement);\n    shader.uniforms[\"sampleWeights\"].value = BlurShaderUtils.createSampleWeights(kernelRadius, stdDev);\n    shader.needsUpdate = true;\n  }\n};\nexport { BlurShaderUtils, DepthLimitedBlurShader };\n//# sourceMappingURL=DepthLimitedBlurShader.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}