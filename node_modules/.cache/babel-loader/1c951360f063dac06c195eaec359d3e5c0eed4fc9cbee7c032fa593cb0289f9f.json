{"ast":null,"code":"import { Vector3, Color } from \"three\";\nconst GodRaysDepthMaskShader = {\n  uniforms: {\n    tInput: {\n      value: null\n    }\n  },\n  vertexShader: (/* glsl */\n  `\n    varying vec2 vUv;\n\n    void main() {\n\n     vUv = uv;\n     gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `),\n  fragmentShader: (/* glsl */\n  `\n    varying vec2 vUv;\n\n    uniform sampler2D tInput;\n\n    void main() {\n\n    \tgl_FragColor = vec4( 1.0 ) - texture2D( tInput, vUv );\n\n    }\n  `)\n};\nconst GodRaysGenerateShader = {\n  uniforms: {\n    tInput: {\n      value: null\n    },\n    fStepSize: {\n      value: 1\n    },\n    vSunPositionScreenSpace: {\n      value: /* @__PURE__ */new Vector3()\n    }\n  },\n  vertexShader: (/* glsl */\n  `\n    varying vec2 vUv;\n\n    void main() {\n\n     vUv = uv;\n     gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `),\n  fragmentShader: (/* glsl */\n  `\n    #define TAPS_PER_PASS 6.0\n\n    varying vec2 vUv;\n\n    uniform sampler2D tInput;\n\n    uniform vec3 vSunPositionScreenSpace;\n    uniform float fStepSize; // filter step size\n\n    void main() {\n\n    // delta from current pixel to \"sun\" position\n\n    \tvec2 delta = vSunPositionScreenSpace.xy - vUv;\n    \tfloat dist = length( delta );\n\n    // Step vector (uv space)\n\n    \tvec2 stepv = fStepSize * delta / dist;\n\n    // Number of iterations between pixel and sun\n\n    \tfloat iters = dist/fStepSize;\n\n    \tvec2 uv = vUv.xy;\n    \tfloat col = 0.0;\n\n    // This breaks ANGLE in Chrome 22\n    //\t- see http://code.google.com/p/chromium/issues/detail?id=153105\n\n    /*\n\t\t// Unrolling didnt do much on my hardware (ATI Mobility Radeon 3450),\n\t\t// so ive just left the loop\n\n\t\tfor ( float i = 0.0; i < TAPS_PER_PASS; i += 1.0 ) {\n\n\t\t// Accumulate samples, making sure we dont walk past the light source.\n\n\t\t// The check for uv.y < 1 would not be necessary with \"border\" UV wrap\n\t\t// mode, with a black border color. I dont think this is currently\n\t\t// exposed by three.js. As a result there might be artifacts when the\n\t\t// sun is to the left, right or bottom of screen as these cases are\n\t\t// not specifically handled.\n\n\t\tcol += ( i <= iters && uv.y < 1.0 ? texture2D( tInput, uv ).r : 0.0 );\n\t\tuv += stepv;\n\n\t\t}\n\t\t*/\n\n    // Unrolling loop manually makes it work in ANGLE\n\n    \tfloat f = min( 1.0, max( vSunPositionScreenSpace.z / 1000.0, 0.0 ) ); // used to fade out godrays\n\n    \tif ( 0.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\n    \tuv += stepv;\n\n    \tif ( 1.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\n    \tuv += stepv;\n\n    \tif ( 2.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\n    \tuv += stepv;\n\n    \tif ( 3.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\n    \tuv += stepv;\n\n    \tif ( 4.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\n    \tuv += stepv;\n\n    \tif ( 5.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\n    \tuv += stepv;\n\n    // Should technically be dividing by iters but TAPS_PER_PASS smooths out\n    // objectionable artifacts, in particular near the sun position. The side\n    // effect is that the result is darker than it should be around the sun, as\n    // TAPS_PER_PASS is greater than the number of samples actually accumulated.\n    // When the result is inverted (in the shader godrays_combine this produces\n    // a slight bright spot at the position of the sun, even when it is occluded.\n\n    \tgl_FragColor = vec4( col/TAPS_PER_PASS );\n    \tgl_FragColor.a = 1.0;\n\n    }\n  `)\n};\nconst GodRaysCombineShader = {\n  uniforms: {\n    tColors: {\n      value: null\n    },\n    tGodRays: {\n      value: null\n    },\n    fGodRayIntensity: {\n      value: 0.69\n    }\n  },\n  vertexShader: (/* glsl */\n  `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `),\n  fragmentShader: (/* glsl */\n  `\n    varying vec2 vUv;\n\n    uniform sampler2D tColors;\n    uniform sampler2D tGodRays;\n\n    uniform float fGodRayIntensity;\n\n    void main() {\n\n    // Since THREE.MeshDepthMaterial renders foreground objects white and background\n    // objects black, the god-rays will be white streaks. Therefore value is inverted\n    // before being combined with tColors\n\n    \tgl_FragColor = texture2D( tColors, vUv ) + fGodRayIntensity * vec4( 1.0 - texture2D( tGodRays, vUv ).r );\n    \tgl_FragColor.a = 1.0;\n\n    }\n  `)\n};\nconst GodRaysFakeSunShader = {\n  uniforms: {\n    vSunPositionScreenSpace: {\n      value: /* @__PURE__ */new Vector3()\n    },\n    fAspect: {\n      value: 1\n    },\n    sunColor: {\n      value: /* @__PURE__ */new Color(16772608)\n    },\n    bgColor: {\n      value: /* @__PURE__ */new Color(0)\n    }\n  },\n  vertexShader: (/* glsl */\n  `\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `),\n  fragmentShader: (/* glsl */\n  `\n    varying vec2 vUv;\n\n    uniform vec3 vSunPositionScreenSpace;\n    uniform float fAspect;\n\n    uniform vec3 sunColor;\n    uniform vec3 bgColor;\n\n    void main() {\n\n    \tvec2 diff = vUv - vSunPositionScreenSpace.xy;\n\n    // Correct for aspect ratio\n\n    \tdiff.x *= fAspect;\n\n    \tfloat prop = clamp( length( diff ) / 0.5, 0.0, 1.0 );\n    \tprop = 0.35 * pow( 1.0 - prop, 3.0 );\n\n    \tgl_FragColor.xyz = ( vSunPositionScreenSpace.z > 0.0 ) ? mix( sunColor, bgColor, 1.0 - prop ) : bgColor;\n    \tgl_FragColor.w = 1.0;\n\n    }\n  `)\n};\nexport { GodRaysCombineShader, GodRaysDepthMaskShader, GodRaysFakeSunShader, GodRaysGenerateShader };\n//# sourceMappingURL=GodRaysShader.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}